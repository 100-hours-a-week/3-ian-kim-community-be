<img width="700" height="700" alt="Image" src="https://github.com/user-attachments/assets/c2336df3-828e-403e-9c90-24d57f49c926" />

위 코드는 인증 과정에서 이메일이 존재하고, 탈퇴하지 않은 회원만 통과시키는 로직입니다. 이메일이 존재하지 않거나 탈퇴한 회원이면 예외를 발생시킵니다.

이 코드의 테스트 코드를 다음과 같이 작성했습니다.
```java
class AuthUserDetailsServiceTest extends IntegrationTestSupport {

    @Autowired
    private UserRepository userRepository;

    @Autowired
    private AuthUserDetailsService sut;

    @Nested
    class loadUserByUsername {

        @Test
        void 이메일이_존재하면_회원이_조회된다() {
            // given
            userRepository.save(UserFixture.createUser("email@example.com", "Password123!", "name", "profileImageName", false));

            // when
            AuthUserDetails userDetails = (AuthUserDetails) sut.loadUserByUsername("email@example.com");

            // then
            assertThat(userDetails.getUsername()).isEqualTo("email@example.com");
            assertThat(userDetails.getPassword()).isEqualTo("Password123!");
            assertThat(userDetails.getProfileImageName()).isEqualTo("profileImageName");
        }

        @Test
        void 이메일이_존재하지_않으면_예외가_발생한다() {
            // given

            // when & then
            assertThatThrownBy(() -> sut.loadUserByUsername("email@example.com"))
                    .isInstanceOf(UsernameNotFoundException.class);
        }

        @Test
        void 이메일이_존재해도_탈퇴한_회원이면_예외가_발생한다() {
            // given
            userRepository.save(UserFixture.createDeletedWithEmail("email@example.com"));

            // when & then
            assertThatThrownBy(() -> sut.loadUserByUsername("email@example.com"))
                    .isInstanceOf(UsernameNotFoundException.class);
        }
    }
}
```

그런데 테스트 커버리지 리포트는 회원이 탈퇴한 경우가 테스트되지 않았다고 하고 있습니다. 저는 분명히 테스트 케이스를 작성했는데 왜 이런 결과가 나왔을까요?

그 이유는 `userRepository.findByEmail()` 메서드에 있었습니다. 제가 `findByEmail` 메서드를 구현할 당시 탈퇴하지 않은 회원만 조회하도록 구현했었던 것입니다. 탈퇴한 회원은 이미 `findByEmail` 메서드에서 걸러지므로 절대 `if`문까지 도달할리가 없었습니다.

이처럼 테스트 커버리지 리포트를 통해 불필요한 운영 코드를 발견할 수 있었고, 의미가 불명확한 `findByEmail` 메서드의 이름을 `findByEmailActive`로 변경함으로써 운영 코드의 품질을 높일 수 있었습니다.
